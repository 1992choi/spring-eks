# 강의
- Inflearn > eks를 활용한 spring 운영서버 배포 (feat. devops의 모든것)

## 정리
### 2. docker 개요
- 도커란?  
  - 애플리케이션을 개발, 배포, 실행을 용이하게 하는 오픈 소스 플랫폼
  - 소프트웨어를 컨테이너라는 표준화된 단위로 패키징하여 어디서든 동일하게 실행 가능
- 도커 이미지(Image)
  - 애플리케이션과 모든 필요한 설정을 포함하는 불변(Immutable)의 템플릿
  - 컨테이너를 실행하기 위한 압축파일과 같은 개념
  - 이미지를 기반으로 실제 실행 단위인 도커 컨테이너가 생성됨
  - 이미지 다운로드(pull)
    - docker pull nginx
  - 이미지 빌드(build)
    - docker build -t 이미지명:태그 .
    - docker build -t 이미지명:태그 -f DockerfileDev .
    - 빌드 컨텍스트란 Docker가 참조할 수 있는 파일과 디렉터리의 위치
    - 현재 위치라면 "." 으로 대체 가능
- 도커 허브(Docker Hub)
  - 다양한 도커 이미지를 찾고 공유할 수 있는 공개 저장소
  - 공식 이미지 및 사용자 제작 이미지를 다운로드 가능
  - 이미지 태그 및 빌드
    - docker build -t username/imagename:tag .
    - 기존 이미지 태그 변경: docker tag 이미지명 username/imagename:tag
  - 이미지 업로드(push)
    - docker push username/imagename:tag
    - 사전에 해당 repository 생성 필요
  - 이미지 다운로드(pull)
    - docker pull username/imagename:tag
- 컨테이너(Container)
  - 이미지로부터 생성되는 실제 실행 인스턴스
  - 라이브러리, 시스템 도구, 코드 등 실행에 필요한 모든 요소 포함
  - 컨테이너 실행(run)
    - docker run -d -p 8080:80 nginx

### 3. spring 빌드환경 이해
- MySQL 설정
  - 컨테이너 실행
    - docker run --name mysql-container -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 mysql:8.0 --default-authentication-plugin=mysql_native_password
  - 스키마 생성
    - create database ordersystem;
- Redis 설정
  - 컨테이너 실행
    - docker run --name redis-container -d -p 6379:6379 redis
- Spring 설정
  - 소스코드 추가
    - 2.ordersystem 폴더 및 소스코드 추가

### 4. docker 이미지 빌드
- 이미지 빌드
  - Dockerfile을 통해 이미지를 생성한다.
  - 명령어
    - docker build -t 이미지명:[태그명] -f <도커 스크립트 파일경로> <빌드 컨텍스트 위치>
      - <도커 스크립트 파일경로>
        - 현재 위치가 Dockerfile이 있는 경로이고, 파일명이 기본값인 Dockerfile이라면 생략 가능하다.
        - DockerfileDev 등 파일명이 다를 경우에는 -f 옵션으로 파일명을 명시해야 한다.
      - <빌드 컨텍스트 위치>
        - Docker 이미지를 빌드할 때 참조할 수 있는 모든 파일과 디렉터리의 위치를 의미한다.
        - 현재 위치에 빌드 대상 파일이 있다면 "." 으로 대체 가능하다.
    - 예시
      - docker build -t demospring:v1.0 .

### 5. docker와 docker-compose 실행
- spring 컨테이너 실행 시 환경설정 주의 사항
  - Spring과 DB를 각각 Docker 컨테이너로 실행할 경우, application-local.yml의 DB 접속 정보를 localhost로 설정하면 정상적으로 연결되지 않는다.
  - 그 이유는 컨테이너 내부에서의 localhost는 해당 컨테이너 자기 자신을 의미하기 때문이다.
  - 즉, Spring 컨테이너에서의 localhost는 Spring 컨테이너 자신을 가리키므로, 별도로 실행된 DB 컨테이너에 접근할 수 없다.
  - 따라서 다음과 같이 설정해야 한다.
    - docker-compose 사용 시 → DB 컨테이너 이름(mysql-container 등)을 host로 지정
    - 로컬 DB에 접근할 경우 → host.docker.internal 사용
- 참고
  - DB는 Docker로 실행하고, Spring은 IntelliJ(로컬)에서 실행하는 경우에는 localhost로 접근 가능하다.
  - 이는 Docker의 포트 매핑(-p 3306:3306)을 통해 호스트와 컨테이너가 연결되기 때문이다.
- docker compose 활용
  - docker-compose란
    - 일반적으로 로컬 환경에서 복수의 컨테이너(Spring, MySQL, Redis 등)를 일괄 기동할 때 사용하는 도구이다.
    - docker 설치 시 함께 설치되며, docker-compose.yml 파일을 기반으로 동작한다.
    - 여러 컨테이너를 하나의 네트워크로 묶어 docker 간 통신이 가능하도록 구성할 수 있다.
    - 동일 네트워크에 속한 컨테이너는 컨테이너 이름을 host처럼 사용할 수 있다.
      - 예) jdbc:mysql://mysql-container:3306/ordersystem
  - docker-compose의 장점
    - 위에서 설명한 컨테이너 간 localhost 통신 문제를 해결할 수 있다.
      - docker-compose를 사용하지 않으면, Spring을 Docker로 실행하는지 IntelliJ(로컬)에서 실행하는지에 따라 application-local.yml의 host 정보를 매번 변경해야 한다.
      - docker-compose를 사용하면 컨테이너 이름 기반 통신이 가능하여 이러한 설정 변경이 필요 없다.
    - 컨테이너 이름을 기반으로 서비스 간 통신이 가능하여 별도의 IP 설정이 필요 없다.
    - 여러 컨테이너를 하나의 설정 파일로 관리할 수 있어 환경 구성이 단순해진다.
    - 개발 환경을 코드로 관리할 수 있어, 동일한 실행 환경을 쉽게 재현할 수 있다.
    - Spring, MySQL, Redis 등 여러 서비스를 하나의 명령어로 일괄 실행 및 종료할 수 있다.
  - 실행
    - docker-compose up -d
      - 정의된 모든 컨테이너를 백그라운드에서 일괄 실행한다.
    - docker-compose up -d --build
      - 이미지 변경 사항이 있을 경우 새로 빌드 후 실행한다.
  - 중지 및 삭제
    - docker-compose down
      - 실행 중인 컨테이너를 일괄 중지하고 네트워크를 함께 정리한다.

### 6. 쿠버네티스 개요
- 쿠버네티스란?
  - 컨테이너화된 애플리케이션을 대규모로 운영하기 위한 컨테이너 오케스트레이션 도구이다.
  - 주로 Docker와 같은 컨테이너 기술과 함께 사용되며, 여러 컨테이너를 자동으로 배포·확장·관리하는 플랫폼이다.
  - 쿠버네티스는 클러스터 기반으로 구성되며, 클러스터는 컨테이너화된 애플리케이션을 실행하기 위한 여러 컴퓨터(노드)의 집합이다.
- 주요 구성 요소
  - 주요 구성 요소
    - ![kubernetes_architecture.png](image/kubernetes_architecture.png)
  - 클러스터
    - 쿠버네티스의 전체 실행 환경을 의미한다.
    - 모든 노드와 쿠버네티스 API 서버 및 관련 구성 요소를 포함한다.
    - 하나의 전체 환경 단위를 하나의 클러스터라고 한다.
    - 클러스터는 크게 마스터 노드(Control Plane)와 워커 노드로 구성된다.
  - 마스터 노드(Control Plane)
    - 클러스터의 관리와 제어를 담당한다.
    - 주요 구성 요소
      - API 서버 (kube-apiserver)
        - 클러스터의 중앙 집중식 관리 시스템이다.
        - 사용자, 내부 구성 요소, 외부 도구가 쿠버네티스 API를 통해 통신하는 진입점이다.
        - 개발자의 명령어(kubectl 등)는 API 서버로 전달된다.
      - 스케줄러 (kube-scheduler)
        - 새로 생성된 파드를 감지하고, 실행할 최적의 워커 노드를 선택한다.
      - etcd
        - 클러스터의 상태 저장소이다.
        - ConfigMap, Secret 등 모든 클러스터 상태 값을 key-value 형태로 저장하는 고가용성 분산 데이터베이스이다.
      - kube-controller-manager
        - 클러스터의 상태 유지를 담당한다.
        - Deployment, ReplicaSet 등을 감시하며 원하는 상태(desired state)와 실제 상태를 일치시키도록 조정한다.
    - 마스터 노드는 안정성과 고가용성이 매우 중요하다.
    - AWS EKS와 같은 관리형 서비스는 마스터 노드의 생성 및 관리를 자동으로 지원한다.
  - 워커 노드
    - 실제 애플리케이션(파드)이 실행되는 노드이다.
    - 각 워커 노드에는 Kubelet이라는 에이전트가 실행되어 마스터 노드와 통신한다.
    - AWS 환경에서는 EC2 인스턴스가 워커 노드 역할을 수행하며, 해당 노드에서 서비스 파드가 실행된다.
    - 주요 구성 요소
      - kubelet
        - API 서버와 통신하여 파드를 시작·중지·관리한다.
        - 파드 상태를 주기적으로 API 서버에 보고한다.
      - kube-proxy
        - 네트워크 프록시 및 로드 밸런서 역할을 수행한다.
        - 네트워크 규칙을 설정하여 파드 간 통신 및 외부에서 파드로의 접근을 가능하게 한다.

### 7. 쿠버네티스 주요 구성 요소
- 구성 요소
  - ![쿠버네티스_핵심요소.png](image/%E1%84%8F%E1%85%AE%E1%84%87%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3_%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9.png)
- 쿠버네티스 핵심 요소
  - 네임스페이스 (Namespace)
    - 클러스터 내 리소스를 논리적으로 분리하는 단위
    - 하나의 클러스터 안에서 개발/운영/테스트 환경을 구분할 때 사용
  - Pod
    - 쿠버네티스에서 배포할 수 있는 가장 작은 단위
    - 1개 이상의 컨테이너로 구성된 배포 단위
    - 일반적으로는 1개의 컨테이너로 구성
  - Service
    - 서비스 디스커버리를 위한 리소스(Resource)
    - 클러스터 내에서 실행 중인 Pod들에 대한 라우팅 및 로드밸런싱 제공
    - 기본 타입은 ClusterIP로, 내부 통신 전용
    - LoadBalancer 등 외부에서 직접 접근 가능한 타입도 존재
  - Ingress
    - 클러스터 외부에서 내부 Service로 트래픽을 라우팅하는 리소스
    - 외부 요청을 내부 Service에 연결해주는 규칙 정의
    - 도메인(Host) 기반 라우팅 지원
  - ReplicaSet
    - 지정된 수의 Pod 복제본이 항상 실행되도록 보장하는 선언적 리소스
    - 장애 발생 시 자동으로 새로운 Pod 생성
  - Deployment
    - ReplicaSet을 관리하는 상위 리소스
    - 단순 개수 유지뿐 아니라 롤링 업데이트, 롤백 등 배포 전략 지원
    - 무중단 배포 및 버전 관리에 활용
  - ConfigMap / Secret
    - ConfigMap
      - 설정 파일과 같은 일반 데이터를 Key-Value 형태로 관리
      - 민감하지 않은 데이터 저장
    - Secret
      - 비밀번호, 인증서 등 민감 정보를 저장
      - Base64 인코딩 형태로 관리
- 주요 특징 및 장점
  - 자동 복구(Self-Healing)
    - 컨테이너 또는 Pod 장애 발생 시 자동 재시작
    - 원하는 상태(Desired State)를 유지하도록 지속적으로 조정
  - 서비스 발견 및 로드밸런싱
    - Service를 통해 내부 DNS 기반 서비스 디스커버리 제공
    - 트래픽을 여러 Pod로 자동 분산
  - 네임스페이스 기반 멀티 환경 지원
    - 개발/운영/테스트 환경을 논리적으로 분리 가능
  - 오토 스케일(Auto Scaling)
    - HPA(Horizontal Pod Autoscaler)
      - CPU/메모리 등 자원 사용률 기준으로 Pod 자동 증설/감소
    - Cluster Autoscaler
      - 노드 자원이 부족할 경우 인스턴스 자동 증설/감소
  - 기타 기능
    - 자동화된 롤아웃 배포(무중단 배포)
    - Pod별 CPU, 메모리 자원 요청/제한 설정 지원

### 8. AWS 핵심요소 - EC2
- Amazon EC2 (Elastic Compute Cloud)
  - AWS에서 제공하는 가상 서버(컴퓨팅) 서비스
  - 다양한 운영 체제(Linux, Windows 등)와 애플리케이션을 실행할 수 있는 확장 가능한 인프라
  - 사용자는 필요한 사양(CPU, 메모리, 스토리지 등)에 맞는 인스턴스 타입을 선택하여 생성 가능
  - 온디맨드, 예약 인스턴스, 스팟 인스턴스 등 다양한 과금 방식 지원
- EC2 주요 개념
  - 인스턴스(Instance)
    - EC2에서 생성한 가상 서버 1대를 의미
    - 선택한 인스턴스 타입에 따라 성능과 비용이 달라짐
  - AMI (Amazon Machine Image)
    - 인스턴스를 생성하기 위한 템플릿 이미지
    - OS, 애플리케이션, 설정 정보 등을 포함
  - 키 페어(Key Pair)
    - EC2 인스턴스에 SSH로 접속하기 위한 인증 수단
    - 공개키/개인키 방식 사용
  - EBS (Elastic Block Store)
    - EC2에 연결하여 사용하는 블록 스토리지
    - 인스턴스 종료 후에도 데이터 유지 가능(옵션 설정에 따라 다름)
- 네트워크 및 보안 관련 핵심 요소
  - 보안 그룹(Security Group)
    - 인스턴스 단위의 가상 방화벽
    - 인바운드(들어오는 트래픽) 및 아웃바운드(나가는 트래픽) 규칙 정의
    - 예: 22번 포트(SSH), 80번 포트(HTTP), 443번 포트(HTTPS) 허용 설정
    - 기본적으로 허용된 트래픽만 통과시키는 화이트리스트 방식
  - 탄력적 IP(Elastic IP)
    - 고정 공인 IP 주소
    - 인스턴스가 재시작되더라도 동일한 공인 IP 유지 가능
- 로드 밸런서(Elastic Load Balancer, ELB)
  - 여러 EC2 인스턴스에 트래픽을 분산시키는 서비스
  - 고가용성 및 확장성 확보에 핵심 역할
  - 로드 밸런서 유형
    - ALB (Application Load Balancer) – HTTP/HTTPS 기반
    - NLB (Network Load Balancer) – TCP/UDP 기반 고성능 처리
  - 타겟 그룹(Target Group)
    - 로드 밸런서가 트래픽을 전달할 백엔드 리소스(EC2 등)의 그룹
    - 헬스 체크를 통해 정상 인스턴스에만 트래픽 전달
- 오토 스케일링(Auto Scaling)
  - 트래픽 증가/감소에 따라 EC2 인스턴스를 자동으로 증설/감소
  - CloudWatch 지표(CPU 사용률 등)를 기준으로 동작
  - 고가용성과 비용 효율성을 동시에 확보 가능
- EC2 활용 관점 정리
  - 애플리케이션 서버, API 서버, 배치 서버 등 다양한 용도로 사용
  - 쿠버네티스(EKS) 환경에서는 워커 노드로 활용
  - 보안 그룹, 로드 밸런서, 오토 스케일링과 함께 구성하여 안정적인 아키텍처 설계 가능

### 9. AWS 핵심요소 - VPC
- AWS VPC (Virtual Private Cloud)
  - AWS 클라우드 내에서 격리된 가상 네트워크를 생성(provisioning)하는 서비스
  - 사용자는 자신의 네트워크 환경처럼 IP 주소 범위, 서브넷, 라우팅 테이블, 게이트웨이 등을 직접 설계 및 제어 가능
  - 즉, AWS 상에서 인프라를 구성하기 위한 네트워크의 기본 단위
- VPC 주요 개념
  - CIDR 블록 (IP 주소의 범위(대역) 를 표기하는 방식. 형식 : IP주소/마스크비트)
    - VPC의 전체 IP 주소 범위를 정의
    - 예: 10.0.0.0/16 → 10.0.0.0 ~ 10.0.255.255 범위 사용 가능
    - 사설 IP 대역을 사용하여 내부 네트워크 구성
  - 서브넷(Subnet)
    - VPC 내 IP 범위를 세분화한 네트워크 단위
    - 예: 10.0.1.0/24 → 10.0.1.0 ~ 10.0.1.255
    - 일반적으로 가용 영역(AZ) 단위로 생성
    - EC2, RDS 등의 리소스는 특정 서브넷에 생성되며 해당 범위 내 IP를 할당받음
    - 퍼블릭 서브넷 / 프라이빗 서브넷으로 구분 가능
      - 퍼블릭 서브넷: 인터넷 게이트웨이(IGW)를 통해 외부 통신 가능
      - 프라이빗 서브넷: 외부에서 직접 접근 불가, 내부 서비스용
  - 인터넷 게이트웨이(IGW)
    - VPC와 인터넷을 연결하는 관문 역할
    - 퍼블릭 서브넷과 연결되어 외부 통신 가능하게 함
  - NAT 게이트웨이
    - 프라이빗 서브넷의 인스턴스가 외부 인터넷으로 나갈 수 있도록 지원
    - 외부에서 직접 접근은 불가능하도록 유지
  - 라우팅 테이블(Route Table)
    - 네트워크 트래픽의 이동 경로를 정의
    - 각 서브넷은 하나의 라우팅 테이블과 연결

### 9. AWS 핵심요소 - RDS
- Amazon RDS (Relational Database Service)
  - 관계형 데이터베이스를 쉽게 설정·운영·확장할 수 있는 AWS 관리형 서비스
  - 인프라 관리(패치, 백업, 장애 복구 등)를 AWS가 대신 수행
  - 지원 엔진: MySQL, PostgreSQL, MariaDB, Oracle, SQL Server 등
- RDS 주요 특징
  - 자동 백업 및 스냅샷
    - 지정된 보존 기간 동안 자동 백업 수행
    - 수동 스냅샷 생성 가능
  - Multi-AZ 배포
    - 기본 DB 인스턴스와 대기(Standby) 인스턴스를 다른 AZ에 구성
    - 장애 발생 시 자동 Failover 지원
    - 고가용성(HA) 보장
  - 읽기 전용 복제본(Read Replica)
    - 읽기 트래픽 분산을 위한 복제 인스턴스
    - 대규모 조회 성능 향상에 활용
  - 자동 패치 및 유지 관리
    - OS 및 DB 엔진 패치를 자동으로 적용
    - 유지 관리 윈도우 설정 가능
- 리전(Region)과 가용 영역(AZ)
  - 리전(Region)
    - 물리적으로 분리된 AWS 인프라의 지리적 집합
    - 전 세계 여러 지역에 분산
  - 가용 영역(Availability Zone, AZ)
    - 하나의 리전 내에 존재하는 독립적인 데이터 센터 그룹
    - 고가용성을 위해 서로 물리적으로 분리되어 있음

### 10. AWS 핵심요소 - IAM 등
- IAM (Identity and Access Management)
  - AWS 리소스에 대한 인증(Authentication)과 권한 부여(Authorization)를 관리하는 서비스
  - "누가(Who) 무엇을(What) 어디까지(Which Resource) 할 수 있는지"를 정의하는 보안의 핵심 요소
- IAM 주요 구성 요소
  - 사용자(User)
    - AWS 서비스에 접근하는 실체(사람 또는 애플리케이션)
    - 루트 사용자(Root User)
      - AWS 계정 생성 시 자동 생성
      - 이메일/비밀번호로 로그인
      - 모든 권한을 가지므로 일상적인 사용은 지양
    - IAM 사용자(IAM User)
      - 개별 계정 ID(12자리), 사용자 이름, 비밀번호로 로그인
      - 필요한 권한만 부여하여 최소 권한 원칙(Least Privilege) 적용
  - 액세스 키(Access Key & Secret Access Key)
    - AWS CLI, SDK, API 호출 등 프로그래매틱 접근을 위한 인증 정보
    - 애플리케이션 또는 스크립트에서 AWS 서비스 호출 시 사용
    - 보안상 루트 사용자의 액세스 키 발급은 권장하지 않음
  - 정책(Policy)
    - JSON 형식의 권한 정의 문서
    - 특정 사용자/그룹/역할이 수행할 수 있는 작업(Action)과 대상 리소스(Resource)를 명시
    - 예: S3 버킷 읽기 허용, EC2 생성 권한 부여 등
    - AWS 관리형 정책 / 사용자 정의 정책으로 구분
  - 역할(Role)
    - 특정 서비스 또는 사용자에게 임시 권한을 부여하는 개념
    - 장기 자격 증명을 저장하지 않고도 안전하게 권한 위임 가능
    - 예: EC2 인스턴스가 S3에 접근하도록 IAM Role 부여
    - EKS, Lambda 등 서비스 연동 시 필수적으로 사용
- IAM 보안 관점 정리
  - 최소 권한 원칙 적용
  - 루트 계정은 MFA(다중 인증) 설정 필수
  - 액세스 키는 주기적 교체 및 노출 방지
  - 역할(Role) 기반 접근 제어 권장

### 10. AWS 핵심요소 - IAM 등 (기타 주요 서비스)
- EKS (Elastic Kubernetes Service)
  - Kubernetes를 AWS에서 관리형으로 제공하는 서비스
  - Control Plane을 AWS가 관리하여 운영 부담 감소
  - IAM과 연동하여 클러스터 접근 제어 가능
- ElastiCache
  - Redis/Memcached를 관리형으로 제공하는 인메모리 캐시 서비스
  - 다중 AZ 복제 및 자동 장애 조치(Failover) 지원
  - 세션 저장, 캐시 처리, 대기 시간 단축에 활용
- MSK (Managed Streaming for Kafka)
  - Apache Kafka를 AWS에서 관리형으로 제공
  - 다중 AZ 배포를 통한 고가용성 보장
  - 대규모 이벤트 스트리밍 및 실시간 데이터 파이프라인 구축에 활용
- S3 (Simple Storage Service)
  - 객체 스토리지 서비스
  - 정적 파일 호스팅, 백업, 로그 저장, 아카이빙 등에 사용
  - 높은 내구성(99.999999999%) 제공
  - 버전 관리 및 수명 주기 정책 설정 가능
- Amazon MQ
  - RabbitMQ, ActiveMQ를 관리형으로 제공하는 메시지 브로커 서비스
  - 레거시 시스템과의 메시징 통합에 활용
- Amazon OpenSearch Service
  - OpenSearch 기반의 관리형 검색/로그 분석 서비스
  - 대규모 데이터 인덱싱 및 검색 처리
  - 클러스터 자동 확장 및 고가용성 지원
- CloudWatch
  - AWS 리소스 및 애플리케이션 모니터링 서비스
  - 로그 수집, 지표(Metric) 분석, 알람 설정 가능
  - 오토 스케일링, 장애 감지, 운영 모니터링에 필수적인 서비스